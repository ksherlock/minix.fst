
	string asis

	include 'gsos.equ'
	include 'minix.equ'
	include 'fst.equ'

	include 'fst.macros'

	include 'M16.Debug'

	include 'records.equ'



	entry path_to_inode
	entry load_inode
	entry find_file

	import id_disk
	import device_read


data	record

path_offset	ds.w 1
more		ds.w 1

	endr

get_file_info	procname export

	with fst_parms
	with dev_parms
	with dp

	;~DebugSetTrace #1


	jsr path_to_inode
	bcs exit

	jsr load_inode
	bcs exit





	;pha ; space
	;~DebugSetTrace #0
	;pla ; prev value


	lda <call_class
	beq class0

class1
	lda [param_blk_ptr] ; pcount
	dec a
	asl a ; x 2
	asl a ; x 4
	tax
	dispatch file_info_dcb_1
	lda tool_error
	cmp #0
	rtl

class0
	ldx #file_info_dcb_0_size-4
	dispatch file_info_dcb_0
	lda tool_error
	cmp #0
	rtl

exit
	rtl

	import do_ignore
	import do_access
	import do_create_date_time, do_mod_date_time
	import do_create_date_time_0, do_mod_date_time_0
	import do_option_list
	import do_file_type, do_aux_type, do_storage_type
	import do_eof, do_blocks, do_r_eof, do_r_blocks

file_info_dcb_0
	dc.w $00, do_ignore ; pathname
	dc.w $04, do_access
	dc.w $06, do_file_type
	dc.w $08, do_aux_type
	dc.w $0c, do_storage_type
	dc.w $0e, do_create_date_time_0
	dc.w $12, do_mod_date_time_0
	dc.w $16, do_blocks
file_info_dcb_0_size equ *-file_info_dcb_0

file_info_dcb_1
	;dc.w $00, do_ignore	; pCount
	dc.w $02, do_ignore ; pathname
	dc.w $06, do_access
	dc.w $08, do_file_type
	dc.w $0a, do_aux_type
	dc.w $0e, do_storage_type
	dc.w $10, do_create_date_time
	dc.w $18, do_mod_date_time
	dc.w $20, do_option_list
	dc.w $24, do_eof
	dc.w $28, do_blocks
	dc.w $2c, do_r_eof
	dc.w $30, do_r_blocks
	endp



load_inode	procname export
	;
	; loads inode into disk_inode.
	;
	; inputs : 
	; my_vcr
	; inode
	; device
	;
	; outputs :
	; disk_inode
	; error in a/c

	; todo -- check if inode # is valid?
	; todo -- check if bit set in imap?


	with fst_parms
	with dev_parms
	with dp

	ldy #vcr.first_inode_block
	lda [my_vcr],y
	asl a ; x 2
	sta dev_blk_num
	;lda #0
	;rol a
	;sta dev_blk_num+2
	stz dev_blk_num+2 ; should be less than 0xffff inode blocks!

	; 32 inodes per block.
	; however, I'd rather read half-block chunks, with means
	; 16 inodes per half-block.
	lda inode
	dec a ; inode 1 is offset 0.
	lsr a ; / 2
	lsr a ; / 4
	lsr a ; / 8
	lsr a ; / 16
	;lsr a ; / 32

	clc
	adc dev_blk_num
	sta dev_blk_num

	lda #512
	sta dev_req_cnt
	sta dev_blk_size

	lda device
	sta dev_num

	jsr device_read
	bcc ok
	rtl
ok

	; find the inode...
	lda inode
	dec a ; inode 1 is offset 0.
	and #$0f
	; multiply by 32
	asl a ; x 2
	asl a ; x 4
	asl a ; x 8
	asl a ; x 16
	asl a ; x 32
	clc
	adc #v1_inode.__sizeof-2
	tay

	;adc io_buffer
	;sta ptr
	;lda #0
	;adc io_buffer+2
	;sta ptr+2

	; copy to dp
	ldx #v1_inode.__sizeof-2
@loop
	lda [io_buffer],y
	sta disk_inode,x
	dey
	dey
	dex
	dex
	bpl @loop

	lda #0
	clc
	rts


	endp

	;
	; sets inode, parent_inode, disk_inode, 
	; if file not present but path is otherwise, ok (eg, create),
	; parent inode and disk_inode will be valid for the parent directory.
	;
	; uses path1, dev1, span1.
	;

path_to_inode	procname export
	with dp,fst_parms


path	equ path1_ptr
dev_num	equ dev1_num
span	equ span1

	stz inode
	lda #1
	sta parent_inode

	lda path_flag
	and #$4000
	bne check_path


no_path
	; device only (eg, .dev1 )
	; 
	lda #1
	sta inode

	lda dev_num
	beq bps
	sta device
	jmp id_disk
	; returns
bps
	lda #bad_path_syntax
	sec
exit
	rts

check_path

	lda span
	cmp #v1L.DIRSIZE+1
	bcs bps

	; but is it relative?

	ldy #2
	lda [path],y
	and #$00ff
	cmp #':'
	beq absolute

	lda #1
	sta inode

	lda dev_num
	beq bps
	sta device
	jsr id_disk
	bcs exit
	lda #2
	sta data.path_offset ; skip past gs-os length word
	brl find_file ; will rts.
	;

absolute
	;
	; worst case ... 
	; 1. extract the volume name.
	; 2. call find_vcr to find it by name
	; 3. if that fails, scan all devices.

	lda #1
	sta inode
	clc
	rts
	
	endp


find_file	procname

	with dp
	with data

	import find_entry_by_name

path	equ fst_parms.path1_ptr
dev_num	equ fst_parms.dev1_num
span	equ fst_parms.span1

	import target:GSString32

	stz more

	; we always need to load inode 1
	lda #1
	sta inode
	jsr load_inode
	_rts.cs


dir_loop

	lda inode
	sta parent_inode

	; get a path component.

	ldx #0
	ldy path_offset

	short m
path_loop
	lda [path],y
	beq eop
	cmp #':'
	beq eop
	sta target.text,x
	inx
	iny
	bra path_loop
eop
	sta more
	long m
	stx target.length
	sty path_offset
	; a = ':' or 0 ... worry about which later!

	; target is valid, inode is valid, is target in inode?

	jsr find_entry_by_name
	bcc @ok
	; may be file_not_found, may be path_not_found.
	ldx more
	beq @exit
	lda #path_not_found
@exit
	sec
	rts

@ok
	; inode,  has been updated.
	jsr load_inode
	_rts.cs

	lda more 
	beq done

	; more to go...

	; this is a directory, right?
	lda disk_inode.mode
	and #S_IFMT
	cmp #S_IFDIR
	beq dir
	lda #path_not_found
	sec
	rts

dir

	; skip the ':'
	short m
	ldy path_offset
loop
	lda [path],y
	beq @ok
	cmp #':'
	bne @ok
	iny
	bra loop
@ok
	long m
	sty path_offset
	bra dir_loop


done
	clc
	rts




	endp

	end
