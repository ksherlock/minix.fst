

	include 'gsos.equ'
	include 'minix.equ'
	include 'fst.equ'

	include 'fst.macros'

	include 'M16.Debug'

	include 'records.equ'



	entry path_to_inode
	entry load_inode

	import id_disk
	import device_read


get_file_info	procname export

	with fst_parms
	with dev_parms
	with dp

	;~DebugSetTrace #1


	jsr path_to_inode
	bcs exit

	jsr load_inode
	bcs exit





	;pha ; space
	;~DebugSetTrace #0
	;pla ; prev value


	lda <call_class
	beq class0

class1
	lda [param_blk_ptr] ; pcount
	dec a
	asl a ; x 2
	asl a ; x 4
	tax
	dispatch file_info_dcb_1
	lda tool_error
	cmp #0
	rtl

class0
	ldx #file_info_dcb_0_size-4
	dispatch file_info_dcb_0
	lda tool_error
	cmp #0
	rtl

exit
	rtl

	import do_ignore
	import do_access
	import do_create_date_time, do_mod_date_time
	import do_create_date_time_0, do_mod_date_time_0
	import do_option_list
	import do_file_type, do_aux_type, do_storage_type
	import do_eof, do_blocks, do_r_eof, do_r_blocks

file_info_dcb_0
	dc.w $00, do_ignore ; pathname
	dc.w $04, do_access
	dc.w $06, do_file_type
	dc.w $08, do_aux_type
	dc.w $0c, do_storage_type
	dc.w $0e, do_create_date_time_0
	dc.w $12, do_mod_date_time_0
	dc.w $16, do_blocks
file_info_dcb_0_size equ *-file_info_dcb_0

file_info_dcb_1
	;dc.w $00, do_ignore	; pCount
	dc.w $02, do_ignore ; pathname
	dc.w $06, do_access
	dc.w $08, do_file_type
	dc.w $0a, do_aux_type
	dc.w $0e, do_storage_type
	dc.w $10, do_create_date_time
	dc.w $18, do_mod_date_time
	dc.w $20, do_option_list
	dc.w $24, do_eof
	dc.w $28, do_blocks
	dc.w $2c, do_r_eof
	dc.w $30, do_r_blocks
	endp



load_inode	proc export
	;
	; loads inode into disk_inode.
	;
	; inputs : 
	; my_vcr
	; inode
	; device
	;
	; outputs :
	; disk_inode
	; error in a/c

	; todo -- check if inode # is valid?
	; todo -- check if bit set in imap?


	with fst_parms
	with dev_parms
	with dp

	ldy #vcr.first_inode_block
	lda [my_vcr],y
	asl a ; x 2
	sta dev_blk_num

	; 32 inodes per block.
	; however, I'd rather read half-block chunks, with means
	; 16 inodes per half-block.
	lda inode
	dec a ; inode 1 is offset 0.
	lsr a ; / 2
	lsr a ; / 4
	lsr a ; / 8
	lsr a ; / 16
	;lsr a ; / 32

	clc
	adc dev_blk_num
	sta dev_blk_num

	lda #512
	sta dev_req_cnt

	lda device
	sta dev_num

	jsr device_read
	bcc ok
	rtl
ok

	; find the inode...
	lda inode
	dec a ; inode 1 is offset 0.
	and #$0f
	; multiply by 32
	asl a ; x 2
	asl a ; x 4
	asl a ; x 8
	asl a ; x 16
	asl a ; x 32
	clc
	adc #v1_inode.__sizeof-2
	tay

	;adc io_buffer
	;sta ptr
	;lda #0
	;adc io_buffer+2
	;sta ptr+2

	; copy to dp
	ldx #v1_inode.__sizeof-2
@loop
	lda [io_buffer],y
	sta disk_inode,x
	dey
	dey
	dex
	dex
	bpl @loop

	lda #0
	clc
	rts


	endp

path_to_inode	proc export
	with dp,fst_parms


path	equ path1_ptr
dev_num	equ dev1_num

	stz inode
	lda #1
	sta parent_inode

	lda path_flag
	and #$4000
	bne check_path


no_path
	; device only (eg, .dev1 )
	; 
	lda #1
	sta inode

	lda dev_num
	beq bps
	sta device
	jmp id_disk
	; returns
bps
	lda #bad_path_syntax
	sec
	rts

check_path
	; but is it relative?

	lda [path]
	and #$00ff
	cmp #':'
	beq absolute

	lda #1
	sta inode

	lda dev_num
	bne bps
	jsr id_disk
	rts

absolute
	;
	; worst case ... 
	; 1. extract the volume name.
	; 2. call find_vcr to find it by name
	; 3. if that fails, scan all devices.

	lda #1
	sta inode
	clc
	rts
	
	endp

	end
