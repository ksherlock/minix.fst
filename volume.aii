	include 'gsos.equ'
	include 'minix.equ'
	include 'records.equ'

	include 'fst.equ'

	include 'fst.macros'

	include 'M16.Debug'


	;
	; VolumeGS / Volume call.
	;
	; check if the disk is ours.  create a VCR or mark it active.
	;

	import id_disk



	import do_file_sys_id
	import do_ignore

	entry do_block_size
	entry do_free_blocks
	entry do_total_blocks
	entry do_vol_name_0
	entry do_vol_name_1

volume	procname	export

	with dp
	with dev_parms
	with fst_parms
	
	stz tool_error

	lda fst_parms.dev1_num
	; if no device, find a volume by name...
	beq by_name

	jsr id_disk
	bcc got_it
	cmp #dup_volume
	beq dup
	sec
	rtl

dup
	; this is a duplicate volume.
	; return the name (and only the name), but also return the error.

	lda <call_class
	beq dup_0

dup_1
	ldy #VolumeRecGS.volName
	jsr do_vol_name_1
	bcs exit
	lda #dup_volume
	bra exit

dup_0
	ldy #VolumeRec.volName
	jsr do_vol_name_0
	bcs exit
	lda #dup_volume
	bra exit


got_it

	lda <call_class
	beq class0


class1
	lda [param_blk_ptr] ; pcount
	dec a
	asl a ; x 2
	asl a ; x 4
	tax
	dispatch volume_dcb_1
	lda tool_error
	cmp #1
	rtl

class0
	ldx #volume_dcb_0_size-4
	dispatch volume_dcb_0
	lda tool_error

exit
	cmp #1
	rtl


by_name
	lda #unknown_vol
	sec
	rtl

volume_dcb_0
	dc.w VolumeRec.deviceName, do_ignore
	dc.w VolumeRec.volName, do_vol_name_1
	dc.w VolumeRec.totalBlocks, do_total_blocks
	dc.w VolumeRec.freeBlocks, do_free_blocks
	dc.w VolumeRec.fileSysID, do_file_sys_id
volume_dcb_0_size equ *-volume_dcb_0

volume_dcb_1
	dc.w VolumeRecGS.devName, do_ignore
	dc.w VolumeRecGS.volName, do_vol_name_1
	dc.w VolumeRecGS.totalBlocks, do_total_blocks
	dc.w VolumeRecGS.freeBlocks, do_free_blocks
	dc.w VolumeRecGS.fileSysID, do_file_sys_id
	dc.w VolumeRecGS.blockSize, do_block_size
	dc.w VolumeRecGS.characteristics, do_ignore
	dc.w VolumeRecGS.deviceID, do_ignore
	endp



do_block_size	proc

	with dp
	with fst_parms

	lda #1024
	sta [param_blk_ptr],y
	rts
	endp

do_total_blocks	proc
	; total blocks = 2 + imap_blocks + zmap_blocks + nzones. I think.

	with dp
	with fst_parms

	phy ; save

	lda #2 ; boot block, super block.
	clc

	; pull from vcr?
	ldy #vcr.super.nzones
	adc [my_vcr],y
	ldy #vcr.super.imap_blocks
	adc [my_vcr],y
	ldy #vcr.super.zmap_blocks
	adc [my_vcr],y

	ply
	sta [param_blk_ptr],y
	rts

	endp


do_free_blocks	proc
	; load the  zmaps and count them up...
	; someday.
	with fst_parms

	lda #0
	sta [param_blk_ptr],y
	rts
	endp

do_vol_name_0	proc
	; store the volume name (class 0)

	with fst_parms
	with dp

	;ldy #VolumeRec.volName
	lda [param_blk_ptr],y
	sta ptr
	iny
	iny
	lda [param_blk_ptr],y
	sta ptr+2

	lda #0
	short m
	lda defaultName ; count.
	tax
	tay
@loop
	lda defaultName,x
	sta [ptr],y
	dex
	dey
	bpl @loop
done
	long m
	clc
	rts


defaultName	str.b ':minix'
	endp

do_vol_name_1	procname

	with fst_parms
	with dp

	;ldy #VolumeRecGS.volName


	lda [param_blk_ptr],y
	sta ptr
	iny
	iny
	lda [param_blk_ptr],y
	sta ptr+2	

	; check the length.
	lda [ptr]
	sec
	sbc #4
	bmi error

	dec a ; - 1 for leading :
	ldy #vcr.vname.length
	cmp [my_vcr],y
	;bcc error_store_size

	ldy #vcr.vname.length
	lda [my_vcr],y
	inc a ; :
	ldy #2
	sta [ptr],y

	bcc error ; still set from cmp.


	phx ; save...

	ldy #4
	short m
	lda #':'
	sta [ptr],y
	long m


	; adjust pointer so y offset
	; matches 
	lda ptr
	sec
	sbc #vcr.vname-3 ; -5 for gs/os name overhead and :
	sta ptr
	lda ptr+2
	sbc #0
	sta ptr+2
	
	ldy #vcr.vname.length
	lda [my_vcr],y ; length
	iny
	iny
	tax
	beq done
	short m
@loop
	lda [my_vcr],y
	sta [ptr],y
	iny
	dex
	bne @loop
	long m

done
	plx ; restore
	clc
	rts

error
	lda #buff_too_small
	sta tool_error
	sec
	rts

;defaultName	str.w ':minix'

	endp

	end

